// file: src/modules/user/user.service.ts (ENHANCED VERSION)

import { ACCOUNT_STATUS, MESSAGES } from "@/constants/app.constants";
import { logger } from "@/middlewares/pino-logger";
import { SocialFollowRepository } from "@/modules/social-feed/social-feed.repository";
import { EmailService } from "@/services/email.service";
import {
  BadRequestException,
  ConflictException,
  NotFoundException,
} from "@/utils/app-error.utils";
import { hashPassword } from "@/utils/password.utils";
import type { IUser } from "./user.interface";
import { UserRepository } from "./user.repository";
import type {
  UpdateUserPayload,
  UserCreatePayload,
  UserResponse,
} from "./user.type";

export class UserService {
  private userRepository: UserRepository;
  private emailService: EmailService;
  private followRepository: SocialFollowRepository;

  constructor() {
    this.userRepository = new UserRepository();
    this.emailService = new EmailService();
    this.followRepository = new SocialFollowRepository();
  }

  toUserResponse(
    user: IUser,
    extras?: { followerCount?: number; followingCount?: number },
  ): UserResponse {
    return {
      _id: user._id.toString(),
      email: user.email,
      fullName: user.fullName,
      phone: user.phoneNumber || "",
      address: user.address || "",
      role: user.role,
      accountStatus: user.accountStatus,
      emailVerified: user.emailVerified,
      lastLoginAt: user.lastLoginAt,
      profileImage: user.profileImageUrl || undefined,
      coverImage: user.coverImageUrl || undefined,
      followerCount: extras?.followerCount,
      followingCount: extras?.followingCount,
      createdAt: user.createdAt,
      updatedAt: user.updatedAt,
    };
  }

  getUserResponse(user: IUser): UserResponse {
    return this.toUserResponse(user);
  }

  async createUser(payload: UserCreatePayload): Promise<IUser> {
    const existing = await this.userRepository.findByEmail(payload.email);
    if (existing) {
      throw new ConflictException(MESSAGES.AUTH.EMAIL_ALREADY_EXISTS);
    }

    const hashedPassword = payload.password
      ? await hashPassword(payload.password)
      : undefined;

    return this.userRepository.create({
      email: payload.email.toLowerCase(),
      password: hashedPassword,
      fullName: payload.fullName,
      phoneNumber: payload.phoneNumber || payload.phone,
      address: payload.address?.trim() ?? "",
      role: payload.role,
      emailVerified: payload.emailVerified ?? false,
      accountStatus: payload.accountStatus ?? ACCOUNT_STATUS.PENDING,
      passwordAutoGenerated: payload.passwordAutoGenerated ?? false,
    });
  }

  async getUserByEmail(email: string): Promise<IUser | null> {
    return this.userRepository.findByEmail(email);
  }

  async getUserByEmailWithPassword(email: string): Promise<IUser | null> {
    return this.userRepository.findByEmailWithPassword(email);
  }

  async getById(userId: string): Promise<IUser | null> {
    return this.userRepository.findById(userId);
  }

  async getUserByIdWithPassword(userId: string): Promise<IUser | null> {
    return this.userRepository.findByIdWithPassword(userId);
  }

  async updateProfile(
    userId: string,
    payload: UpdateUserPayload,
  ): Promise<UserResponse> {
    const user = await this.userRepository.findById(userId);
    if (!user) {
      throw new NotFoundException(MESSAGES.USER.USER_NOT_FOUND);
    }

    const updates: Partial<IUser> = {};

    if (payload.fullName !== undefined) {
      updates.fullName = payload.fullName.trim();
    }

    if (payload.address !== undefined) {
      updates.address = payload.address.trim();
    }

    const phone = payload.phoneNumber ?? payload.phone;
    if (phone !== undefined) {
      updates.phoneNumber = phone;
    }

    if (Object.keys(updates).length === 0) {
      throw new BadRequestException("No profile fields provided to update.");
    }

    const updated = await this.userRepository.updateById(userId, updates);
    if (!updated) {
      throw new NotFoundException(MESSAGES.USER.USER_NOT_FOUND);
    }

    return this.toUserResponse(updated);
  }

  async updateProfileImage(
    userId: string,
    imageUrl: string,
  ): Promise<UserResponse> {
    if (!imageUrl) {
      throw new BadRequestException("Profile image URL is required.");
    }

    const updated = await this.userRepository.updateById(userId, {
      profileImageUrl: imageUrl,
    });

    if (!updated) {
      throw new NotFoundException(MESSAGES.USER.USER_NOT_FOUND);
    }

    return this.toUserResponse(updated);
  }

  async updateCoverImage(
    userId: string,
    imageUrl: string,
  ): Promise<UserResponse> {
    if (!imageUrl) {
      throw new BadRequestException("Cover image URL is required.");
    }

    const updated = await this.userRepository.updateById(userId, {
      coverImageUrl: imageUrl,
    });

    if (!updated) {
      throw new NotFoundException(MESSAGES.USER.USER_NOT_FOUND);
    }

    return this.toUserResponse(updated);
  }

  async listFollowing(userId: string): Promise<UserResponse[]> {
    const followingIds = await this.followRepository.findFollowingIds(userId);
    if (followingIds.length === 0) return [];

    const followingUsers = await this.userRepository.find({
      _id: { $in: followingIds },
      isDeleted: { $ne: true },
    });

    return followingUsers.map((user) => this.toUserResponse(user));
  }

  async listFollowers(userId: string): Promise<UserResponse[]> {
    const followerIds = await this.followRepository.findFollowerIds(userId);
    if (followerIds.length === 0) return [];

    const followerUsers = await this.userRepository.find({
      _id: { $in: followerIds },
      isDeleted: { $ne: true },
    });

    return followerUsers.map((user) => this.toUserResponse(user));
  }

  async getUsersByRole(role: string): Promise<IUser[]> {
    return this.userRepository.findByRole(role);
  }

  async markEmailAsVerified(userId: string): Promise<IUser | null> {
    return this.userRepository.markEmailAsVerified(userId);
  }

  async updatePassword(userId: string, hashedPassword: string): Promise<void> {
    await this.userRepository.updatePassword(userId, hashedPassword);
  }

  async updateAutoGeneratedPassword(
    userId: string,
    password: string,
  ): Promise<void> {
    const hashedPassword = await hashPassword(password);
    await this.userRepository.updateAutoGeneratedPassword(
      userId,
      hashedPassword,
    );
  }

  async updateLastLogin(userId: string): Promise<void> {
    await this.userRepository.updateLastLogin(userId);
  }

  async invalidateAllRefreshTokens(userId: string): Promise<void> {
    await this.userRepository.deleteAllRefreshTokens(userId);
  }

  async notifyPasswordChange(
    email: string,
    fullName: string,
    changedAt: Date,
  ): Promise<void> {
    try {
      await this.emailService.sendPasswordChangeNotification({
        to: email,
        userName: fullName,
        changedAt,
      });
    } catch (error) {
      logger.warn({ email, error }, "Password change notification failed");
    }
  }

  async getProfile(userId: string): Promise<UserResponse> {
    const user = await this.userRepository.findById(userId);
    if (!user) {
      throw new NotFoundException(MESSAGES.USER.USER_NOT_FOUND);
    }

    const [followerCount, followingCount] = await Promise.all([
      this.followRepository.countFollowers(userId),
      this.followRepository.countFollowing(userId),
    ]);

    return this.toUserResponse(user, { followerCount, followingCount });
  }

  async getProfileOrNull(
    userId: string,
    options: { includeDeleted?: boolean } = {}
  ): Promise<UserResponse | null> {
    const user = options.includeDeleted
      ? await this.userRepository.findByIdIncludingDeleted(userId)
      : await this.userRepository.findById(userId);

    if (!user) {
      return null;
    }

    const [followerCount, followingCount] = await Promise.all([
      this.followRepository.countFollowers(userId),
      this.followRepository.countFollowing(userId),
    ]);

    return this.toUserResponse(user, { followerCount, followingCount });
  }
}
