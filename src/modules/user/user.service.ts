// file: src/modules/user/user.service.ts (ENHANCED VERSION)

import { ACCOUNT_STATUS, MESSAGES, ROLES } from "@/constants/app.constants";
import { logger } from "@/middlewares/pino-logger";
import { SocialFollowRepository } from "@/modules/social-feed/social-feed.repository";
import { EmailService } from "@/services/email.service";
import {
  BadRequestException,
  ConflictException,
  NotFoundException,
} from "@/utils/app-error.utils";
import { hashPassword } from "@/utils/password.utils";
import type { IUser } from "./user.interface";
import { UserRepository } from "./user.repository";
import type {
  UpdateUserPayload,
  UserCreatePayload,
  UserResponse,
} from "./user.type";

export class UserService {
  private userRepository: UserRepository;
  private emailService: EmailService;
  private followRepository: SocialFollowRepository;

  constructor() {
    this.userRepository = new UserRepository();
    this.emailService = new EmailService();
    this.followRepository = new SocialFollowRepository();
  }

  toUserResponse(
    user: IUser,
    extras?: { followerCount?: number; followingCount?: number },
  ): UserResponse {
    return {
      _id: user._id.toString(),
      email: user.email ?? "",
      fullName: user.fullName,
      userName: user.userName || user.fullName,
      phoneNumber: user.phoneNumber || user.phoneNumber || "",
      address: user.address || "",
      bio: user.bio || "",
      role: user.role,
      accountStatus: user.accountStatus,
      emailVerified: user.emailVerified,
      lastLoginAt: user.lastLoginAt,
      profileImage: user.profileImageUrl ?? null,
      coverImage: user.coverImageUrl ?? null,
      profileImageUrl: user.profileImageUrl ?? null,
      coverImageUrl: user.coverImageUrl ?? null,
      followerCount: extras?.followerCount,
      followingCount: extras?.followingCount,
      createdAt: user.createdAt,
      updatedAt: user.updatedAt,
    };
  }

  getUserResponse(user: IUser): UserResponse {
    return this.toUserResponse(user);
  }

  async createUser(payload: UserCreatePayload): Promise<IUser> {
    const normalizedEmail = payload.email?.trim();
    if (!normalizedEmail && payload.role !== ROLES.GOLF_CLUB) {
      throw new BadRequestException("Email is required.");
    }

    if (normalizedEmail) {
      const existing = await this.userRepository.findByEmail(normalizedEmail);
      if (existing) {
        throw new ConflictException(MESSAGES.AUTH.EMAIL_ALREADY_EXISTS);
      }
    }

    if (payload.userName) {
      const existingUserName = await this.userRepository.findByUserName(
        payload.userName.trim(),
      );
      if (existingUserName) {
        throw new ConflictException("Username is already taken.");
      }
    }

    const hashedPassword = payload.password
      ? await hashPassword(payload.password)
      : undefined;

    return this.userRepository.create({
      email: normalizedEmail ? normalizedEmail.toLowerCase() : undefined,
      password: hashedPassword,
      fullName: payload.fullName,
      userName: payload.userName?.trim(),
      phoneNumber: payload.phoneNumber ?? undefined,
      address: payload.address?.trim() ?? "",
      bio: payload.bio?.trim() ?? "",
      role: payload.role,
      emailVerified: payload.emailVerified ?? false,
      accountStatus: payload.accountStatus ?? ACCOUNT_STATUS.PENDING,
      passwordAutoGenerated: payload.passwordAutoGenerated ?? false,
    });
  }

  async getUserByEmail(email: string): Promise<IUser | null> {
    return this.userRepository.findByEmail(email);
  }

  async getUserByEmailOrUserNameWithPassword(
    identifier: string,
  ): Promise<IUser | null> {
    return this.userRepository.findByEmailOrUserNameWithPassword(identifier);
  }

  async isUserNameTaken(userName: string): Promise<boolean> {
    const normalized = userName.trim();
    if (!normalized) return false;
    const existing = await this.userRepository.findByUserName(normalized);
    return Boolean(existing);
  }

  async getUserByEmailWithPassword(email: string): Promise<IUser | null> {
    return this.userRepository.findByEmailWithPassword(email);
  }

  async getById(userId: string): Promise<IUser | null> {
    return this.userRepository.findById(userId);
  }

  async getUserByIdWithPassword(userId: string): Promise<IUser | null> {
    return this.userRepository.findByIdWithPassword(userId);
  }

  async getUsersByIds(userIds: string[]): Promise<IUser[]> {
    if (userIds.length === 0) {
      return [];
    }

    return this.userRepository.find({
      _id: { $in: userIds },
      isDeleted: { $ne: true },
    });
  }

  async findGolfersByMentionHandles(handles: string[]): Promise<IUser[]> {
    return this.userRepository.findGolfersByMentionHandles(handles);
  }

  async updateProfile(
    userId: string,
    payload: UpdateUserPayload,
  ): Promise<UserResponse> {
    const user = await this.userRepository.findById(userId);
    if (!user) {
      throw new NotFoundException(MESSAGES.USER.USER_NOT_FOUND);
    }

    const updates: Partial<IUser> = {};

    if (payload.fullName !== undefined) {
      updates.fullName = payload.fullName.trim();
    }

    if (payload.userName !== undefined) {
      const desiredUserName = payload.userName.trim();
      if (desiredUserName) {
        const existing =
          await this.userRepository.findByUserName(desiredUserName);
        if (existing && existing._id.toString() !== userId) {
          throw new ConflictException("Username is already taken.");
        }
        updates.userName = desiredUserName;
      } else {
        updates.userName = undefined;
      }
    }

    if (payload.address !== undefined) {
      updates.address = payload.address.trim();
    }

    const phoneNumber = payload.phoneNumber;
    if (phoneNumber !== undefined) {
      const normalizedPhone =
        typeof phoneNumber === "string" ? phoneNumber.trim() : phoneNumber;
      updates.phoneNumber = normalizedPhone;
      updates.phoneNumber = normalizedPhone;
    }

    if (payload.phoneNumber !== undefined) {
      const normalizedPhone =
        typeof payload.phoneNumber === "string"
          ? payload.phoneNumber.trim()
          : payload.phoneNumber;
      updates.phoneNumber = normalizedPhone;
    }

    if (payload.bio !== undefined) {
      updates.bio = payload.bio.trim();
    }

    if (payload.profileImageUrl !== undefined) {
      updates.profileImageUrl = payload.profileImageUrl;
    }

    if (payload.coverImageUrl !== undefined) {
      updates.coverImageUrl = payload.coverImageUrl;
    }

    if (Object.keys(updates).length === 0) {
      throw new BadRequestException("No profile fields provided to update.");
    }

    const updated = await this.userRepository.updateById(userId, updates);
    if (!updated) {
      throw new NotFoundException(MESSAGES.USER.USER_NOT_FOUND);
    }

    return this.toUserResponse(updated);
  }

  async updateProfileImage(
    userId: string,
    imageUrl: string,
  ): Promise<UserResponse> {
    if (!imageUrl) {
      throw new BadRequestException("Profile image URL is required.");
    }

    const updated = await this.userRepository.updateById(userId, {
      profileImageUrl: imageUrl,
    });

    if (!updated) {
      throw new NotFoundException(MESSAGES.USER.USER_NOT_FOUND);
    }

    return this.toUserResponse(updated);
  }

  async updateCoverImage(
    userId: string,
    imageUrl: string,
  ): Promise<UserResponse> {
    if (!imageUrl) {
      throw new BadRequestException("Cover image URL is required.");
    }

    const updated = await this.userRepository.updateById(userId, {
      coverImageUrl: imageUrl,
    });

    if (!updated) {
      throw new NotFoundException(MESSAGES.USER.USER_NOT_FOUND);
    }

    return this.toUserResponse(updated);
  }

  async updateAccountStatus(
    userId: string,
    accountStatus: (typeof ACCOUNT_STATUS)[keyof typeof ACCOUNT_STATUS],
  ): Promise<UserResponse> {
    const updated = await this.userRepository.updateById(userId, {
      accountStatus,
    });
    if (!updated) {
      throw new NotFoundException(MESSAGES.USER.USER_NOT_FOUND);
    }

    if (accountStatus !== ACCOUNT_STATUS.ACTIVE) {
      await this.invalidateAllRefreshTokens(userId);
    }

    return this.toUserResponse(updated);
  }

  async softDeleteUser(userId: string): Promise<void> {
    const deleted = await this.userRepository.softDelete(userId);
    if (!deleted) {
      throw new NotFoundException(MESSAGES.USER.USER_NOT_FOUND);
    }
    await this.invalidateAllRefreshTokens(userId);
  }

  async listFollowing(userId: string): Promise<UserResponse[]> {
    const followingIds = await this.followRepository.findFollowingIds(userId);
    if (followingIds.length === 0) return [];

    const followingUsers = await this.userRepository.find({
      _id: { $in: followingIds },
      isDeleted: { $ne: true },
    });

    return followingUsers.map((user) => this.toUserResponse(user));
  }

  async listFollowers(userId: string): Promise<UserResponse[]> {
    const followerIds = await this.followRepository.findFollowerIds(userId);
    if (followerIds.length === 0) return [];

    const followerUsers = await this.userRepository.find({
      _id: { $in: followerIds },
      isDeleted: { $ne: true },
    });

    return followerUsers.map((user) => this.toUserResponse(user));
  }

  async getUsersByRole(role: string): Promise<IUser[]> {
    return this.userRepository.findByRole(role);
  }

  async markEmailAsVerified(userId: string): Promise<IUser | null> {
    return this.userRepository.markEmailAsVerified(userId);
  }

  async updatePassword(userId: string, hashedPassword: string): Promise<void> {
    await this.userRepository.updatePassword(userId, hashedPassword);
  }

  async updateAutoGeneratedPassword(
    userId: string,
    password: string,
  ): Promise<void> {
    const hashedPassword = await hashPassword(password);
    await this.userRepository.updateAutoGeneratedPassword(
      userId,
      hashedPassword,
    );
  }

  async updateLastLogin(userId: string): Promise<void> {
    await this.userRepository.updateLastLogin(userId);
  }

  async invalidateAllRefreshTokens(userId: string): Promise<void> {
    await this.userRepository.deleteAllRefreshTokens(userId);
  }

  async permanentlyDeleteUser(userId: string): Promise<void> {
    await this.userRepository.permanentlyDeleteUser(userId);
  }

  async notifyPasswordChange(
    email: string,
    fullName: string,
    changedAt: Date,
  ): Promise<void> {
    try {
      await this.emailService.sendPasswordChangeNotification({
        to: email,
        userName: fullName,
        changedAt,
      });
    } catch (error) {
      logger.warn({ email, error }, "Password change notification failed");
    }
  }

  async getProfile(userId: string): Promise<UserResponse> {
    const user = await this.userRepository.findById(userId);
    if (!user) {
      throw new NotFoundException(MESSAGES.USER.USER_NOT_FOUND);
    }

    const [followerCount, followingCount] = await Promise.all([
      this.followRepository.countFollowers(userId),
      this.followRepository.countFollowing(userId),
    ]);

    return this.toUserResponse(user, { followerCount, followingCount });
  }

  async getProfileOrNull(
    userId: string,
    options: { includeDeleted?: boolean } = {},
  ): Promise<UserResponse | null> {
    const user = options.includeDeleted
      ? await this.userRepository.findByIdIncludingDeleted(userId)
      : await this.userRepository.findById(userId);

    if (!user) {
      return null;
    }

    const [followerCount, followingCount] = await Promise.all([
      this.followRepository.countFollowers(userId),
      this.followRepository.countFollowing(userId),
    ]);

    return this.toUserResponse(user, { followerCount, followingCount });
  }
}
