// file: src/modules/user/user.repository.ts

import { ACCOUNT_STATUS, ROLES } from "@/constants/app.constants";
import { logger } from "@/middlewares/pino-logger";
import { BaseRepository } from "@/modules/base/base.repository";
import type { IUser } from "./user.interface";
import { RefreshTokenBlacklist, User } from "./user.model";

/**
 * User Repository
 */
export class UserRepository extends BaseRepository<IUser> {
  constructor() {
    super(User);
  }

  private escapeRegExp(value: string) {
    return value.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
  }

  async findByEmail(email: string): Promise<IUser | null> {
    if (!email) {
      return null;
    }
    const normalized = email.toLowerCase();
    return this.model
      .findOne({ email: normalized, isDeleted: false })
      .exec();
  }

  async findByEmailWithPassword(email: string): Promise<IUser | null> {
    if (!email) {
      return null;
    }
    const normalized = email.toLowerCase();
    return this.model
      .findOne({ email: normalized, isDeleted: false })
      .select("+password")
      .exec();
  }

  async findByUserName(userName: string): Promise<IUser | null> {
    return this.model
      .findOne({ userName, isDeleted: false })
      .exec();
  }

  async findGolfersByMentionHandles(handles: string[]): Promise<IUser[]> {
    const normalized = Array.from(
      new Set(
        (handles ?? [])
          .map((h) => (typeof h === "string" ? h.trim() : ""))
          .filter(Boolean)
          .slice(0, 25),
      ),
    );

    if (normalized.length === 0) {
      return [];
    }

    const patterns = normalized.map((handle) => {
      const safe = this.escapeRegExp(handle);
      return new RegExp(`^@?${safe}$`, "i");
    });

    return this.model
      .find({
        role: ROLES.GOLFER,
        isDeleted: false,
        userName: { $in: patterns },
      })
      .exec();
  }

  async findByEmailOrUserNameWithPassword(
    identifier: string,
  ): Promise<IUser | null> {
    if (!identifier) return null;
    const trimmed = identifier.trim();
    if (!trimmed) return null;
    const normalized = trimmed.toLowerCase();

    return this.model
      .findOne({
        isDeleted: false,
        $or: [
          { email: normalized },
          { userName: trimmed },
          { userName: normalized },
        ],
      })
      .select("+password")
      .exec();
  }

  async findByVerificationToken(token: string): Promise<IUser | null> {
    return this.model
      .findOne({
        emailVerificationToken: token,
        isDeleted: false,
      })
      .select("+emailVerificationToken +emailVerificationExpiresAt")
      .exec();
  }

  async findByRole(role: string): Promise<IUser[]> {
    return this.model.find({ role, isDeleted: false }).exec();
  }

  async findByAccountStatus(status: string): Promise<IUser[]> {
    return this.model.find({ accountStatus: status, isDeleted: false }).exec();
  }

  async markEmailAsVerified(userId: string): Promise<IUser | null> {
    return this.model
      .findByIdAndUpdate(
        userId,
        {
          emailVerified: true,
          emailVerificationToken: undefined,
          emailVerificationExpiresAt: undefined,
          accountStatus: ACCOUNT_STATUS.ACTIVE,
        },
        { new: true }
      )
      .exec();
  }

  async updateVerificationToken(
    userId: string,
    data: {
      emailVerificationToken?: string;
      emailVerificationExpiresAt?: Date;
    }
  ): Promise<IUser | null> {
    return this.model.findByIdAndUpdate(userId, data, { new: true }).exec();
  }

  async updatePassword(
    userId: string,
    hashedPassword: string
  ): Promise<IUser | null> {
    return this.model
      .findByIdAndUpdate(
        userId,
        {
          password: hashedPassword,
          passwordChangedAt: new Date(),
          mustChangePassword: false,
          passwordAutoGenerated: false,
        },
        { new: true }
      )
      .exec();
  }

  async updateAutoGeneratedPassword(
    userId: string,
    hashedPassword: string
  ): Promise<IUser | null> {
    return this.model
      .findByIdAndUpdate(
        userId,
        {
          password: hashedPassword,
          passwordChangedAt: new Date(),
          passwordAutoGenerated: true,
        },
        { new: true }
      )
      .exec();
  }

  async updateLastLogin(userId: string): Promise<IUser | null> {
    return this.model
      .findByIdAndUpdate(userId, { lastLoginAt: new Date() }, { new: true })
      .exec();
  }

  async permanentlyDeleteUser(userId: string): Promise<any> {
    return this.model.deleteOne({ _id: userId }).exec();
  }

  async countByRole(role: string): Promise<number> {
    return this.model.countDocuments({ role, isDeleted: false }).exec();
  }

  async countActiveUsers(): Promise<number> {
    return this.model
      .countDocuments({ accountStatus: ACCOUNT_STATUS.ACTIVE, isDeleted: false })
      .exec();
  }

  async findByIdWithPassword(userId: string): Promise<IUser | null> {
    return this.model.findById(userId).select("+password").exec();
  }

  /**
   * Find user by id including soft-deleted records.
   */
  async findByIdIncludingDeleted(userId: string): Promise<IUser | null> {
    return this.model
      .findById(userId)
      .setOptions({ includeDeleted: true })
      .exec();
  }

  async deleteAllRefreshTokens(userId: string): Promise<number> {
    try {
      const result = await RefreshTokenBlacklist.deleteMany({
        userId: userId,
      });

      return result.deletedCount || 0;
    } catch (error) {
      logger.error({ userId, error }, "Error deleting refresh tokens");
      throw error;
    }
  }
}
