import { ACCOUNT_STATUS, MESSAGES, ROLES } from "@/constants/app.constants";
import { logger } from "@/middlewares/pino-logger";
import { EmailService } from "@/services/email.service";
import {
  BadRequestException,
  ConflictException,
  NotFoundException,
} from "@/utils/app-error.utils";
import { Types } from "mongoose";
import { UserService } from "../user/user.service";
import type { UserResponse } from "../user/user.type";
import type { IGolfClubRoleAssignment } from "./golf-club-role.interface";
import { CLUB_ROLES } from "./golf-club-role.model";
import type { IGolfClub, IGolfClubMember } from "./golf-club.interface";
import { ChatService } from "../chat/chat.service";
import {
  GolfClubMemberRepository,
  GolfClubRepository,
  GolfClubRoleRepository,
} from "./golf-club.repository";
import type {
  AddClubMemberPayload,
  AssignClubManagerPayload,
  ClubRole,
  ClubRoleAssignmentPayload,
  ClubRolesResponse,
  CreateGolfClubPayload,
  GolfClubMemberResponse,
  GolfClubResponse,
} from "./golf-club.type";

type ClubRoleEntry = {
  golferId: string;
  user: UserResponse;
  roles: ClubRole[];
};

export class GolfClubService {
  private golfClubRepository: GolfClubRepository;
  private golfClubMemberRepository: GolfClubMemberRepository;
  private golfClubRoleRepository: GolfClubRoleRepository;
  private userService: UserService;
  private emailService: EmailService;
  private chatService: ChatService;

  constructor() {
    this.golfClubRepository = new GolfClubRepository();
    this.golfClubMemberRepository = new GolfClubMemberRepository();
    this.golfClubRoleRepository = new GolfClubRoleRepository();
    this.userService = new UserService();
    this.emailService = new EmailService();
    this.chatService = new ChatService();
  }

  private resolveClubPassword(
    club: IGolfClub,
    provided?: string,
  ): string {
    const password = (provided ?? club.clubPassword ?? "").trim();
    if (!password) {
      throw new BadRequestException(
        "Club password is missing. Please set a club password before assigning managers.",
      );
    }
    return password;
  }

  async createGolfClub(
    payload: CreateGolfClubPayload,
    adminEmail: string,
  ): Promise<GolfClubResponse> {
    const clubName = payload.clubName.trim();
    const passwordToUse = payload.password.trim();
    const managerIds = Array.from(new Set(payload.managerIds || []));

    let managerMap = new Map<string, UserResponse>();
    if (managerIds.length > 0) {
      const managers = await this.userService.getUsersByIds(managerIds);
      managerMap = new Map(
        managers.map((manager) => [
          manager._id.toString(),
          this.userService.toUserResponse(manager),
        ]),
      );

      const missingManagerId = managerIds.find(
        (id) =>
          !managerMap.has(id) || managerMap.get(id)?.role !== ROLES.GOLFER,
      );
      if (missingManagerId) {
        throw new BadRequestException(
          "One or more selected managers are invalid golfers.",
        );
      }
    }

    const clubUser = await this.userService.createUser({
      email: payload.email,
      password: passwordToUse,
      fullName: clubName,
      role: ROLES.GOLF_CLUB,
      emailVerified: true,
      accountStatus: ACCOUNT_STATUS.ACTIVE,
      address: payload.address ?? "",
      passwordAutoGenerated: false,
    });

    const club = await this.golfClubRepository.create({
      name: clubName,
      clubUserId: clubUser._id,
      clubPassword: passwordToUse,
      managerUserId: managerIds[0] ? new Types.ObjectId(managerIds[0]) : null,
      address: payload.address?.trim() ?? "",
    });

    // Persist manager role assignments
    if (managerIds.length > 0) {
      for (const managerId of managerIds) {
        await this.golfClubRoleRepository.create({
          clubId: new Types.ObjectId(club._id),
          golferUserId: new Types.ObjectId(managerId),
          roles: [CLUB_ROLES.CLUB_MANAGER],
        } as Partial<IGolfClubRoleAssignment>);
      }
    }

    // Create default group chat for the club including existing members/managers
    try {
      const thread = await this.chatService.createClubGroupThread(
        clubUser._id.toString(),
        `${clubName} Club`,
      );
      await this.golfClubRepository.updateById(club._id.toString(), {
        groupThreadId: new Types.ObjectId(thread._id),
      } as Partial<IGolfClub>);
    } catch (error) {
      logger.error(
        { clubId: club._id.toString(), error },
        "Failed to create club group chat thread",
      );
    }

    await this.emailService.sendGolfClubCredentials({
      to: adminEmail,
      recipientRole: "Admin",
      clubName,
      clubEmail: clubUser.email,
      clubPassword: passwordToUse,
    });

    // Notify each manager directly so they can log in immediately
    for (const managerId of managerIds) {
      const manager = managerMap.get(managerId)!;
      await this.emailService.sendGolfClubCredentials({
        to: manager.email,
        recipientName: manager.fullName,
        recipientRole: "Club Manager",
        clubName,
        clubEmail: clubUser.email,
        clubPassword: passwordToUse,
      });
    }

    return this.toGolfClubResponse(club, clubUser.email);
  }

  async listGolfers(): Promise<UserResponse[]> {
    const golfers = await this.userService.getUsersByRole(ROLES.GOLFER);
    return golfers.map((golfer) => this.userService.toUserResponse(golfer));
  }

  async listGolfClubs(): Promise<GolfClubResponse[]> {
    const clubs = await this.golfClubRepository.findAll();
    if (clubs.length === 0) {
      return [];
    }

    const clubUserIds = Array.from(
      new Set(clubs.map((club) => club.clubUserId.toString())),
    );
    const clubUsers = await this.userService.getUsersByIds(clubUserIds);
    const clubUserMap = new Map(
      clubUsers.map((user) => [user._id.toString(), user.email]),
    );

    const clubRoleCounts = await this.golfClubRoleRepository.countByClubIds(
      clubs.map((club) => club._id.toString()),
    );

    return clubs.map((club) =>
      this.toGolfClubResponse(
        club,
        clubUserMap.get(club.clubUserId.toString()) ?? "",
        clubRoleCounts.get(club._id.toString()) ?? 0,
      ),
    );
  }

  async getClubRoles(clubId: string): Promise<ClubRolesResponse> {
    const club = await this.golfClubRepository.findById(clubId);
    if (!club) {
      throw new NotFoundException("Golf club not found.");
    }

    const assignments = await this.golfClubRoleRepository.findByClubId(clubId);
    if (assignments.length === 0) {
      return {
        clubId,
        managers: [],
        members: [],
        assignments: [],
      };
    }

    const golferIds = Array.from(
      new Set(
        assignments.map((assignment) => assignment.golferUserId.toString()),
      ),
    );
    const golfers = await this.userService.getUsersByIds(golferIds);
    const golferMap = new Map(
      golfers.map((golfer) => [golfer._id.toString(), golfer]),
    );

    const enrichedAssignments = assignments
      .map((assignment) => {
        const golfer = golferMap.get(assignment.golferUserId.toString());
        if (!golfer) {
          return null;
        }
        return {
          golferId: assignment.golferUserId.toString(),
          user: this.userService.toUserResponse(golfer),
          roles: assignment.roles,
        } as ClubRoleEntry;
      })
      .filter((item): item is ClubRoleEntry => Boolean(item));

    const managers = enrichedAssignments.filter((item) =>
      item.roles.includes(CLUB_ROLES.CLUB_MANAGER),
    );
    const members = enrichedAssignments.filter((item) =>
      item.roles.includes(CLUB_ROLES.CLUB_MEMBER),
    );

    return {
      clubId,
      managers,
      members,
      assignments: enrichedAssignments,
    };
  }

  async getClubRolesByClubUserId(
    clubUserId: string,
  ): Promise<ClubRolesResponse> {
    const club = await this.golfClubRepository.findByClubUserId(clubUserId);
    if (!club) {
      throw new NotFoundException("Golf club not found.");
    }

    return this.getClubRoles(club._id.toString());
  }

  async updateClubRoles(
    payload: ClubRoleAssignmentPayload,
  ): Promise<ClubRolesResponse> {
    const club = await this.golfClubRepository.findById(payload.clubId);
    if (!club) {
      throw new NotFoundException("Golf club not found.");
    }

    const managerIds = payload.managerIds ?? [];
    const memberIds = payload.memberIds ?? [];

    const managerSet = new Set(managerIds);
    const memberSet = new Set(memberIds);
    const combinedIds = new Set<string>([...managerSet, ...memberSet]);
    const memberIdsForThread = Array.from(combinedIds);

    const golferIds = Array.from(combinedIds);
    const golfers =
      golferIds.length > 0
        ? await this.userService.getUsersByIds(golferIds)
        : [];
    const golferMap = new Map(
      golfers.map((golfer) => [golfer._id.toString(), golfer]),
    );

    const missingGolferId = golferIds.find((id) => !golferMap.has(id));
    if (missingGolferId) {
      throw new NotFoundException(MESSAGES.USER.USER_NOT_FOUND);
    }

    for (const id of golferIds) {
      const golfer = golferMap.get(id)!;
      if (golfer.role !== ROLES.GOLFER) {
        throw new BadRequestException("Selected user is not a golfer.");
      }
    }

    // Track existing manager ids to detect newly added managers
    const existingAssignments = await this.golfClubRoleRepository.findByClubId(
      payload.clubId,
    );
    const existingManagerIds = new Set(
      existingAssignments
        .filter((a) => a.roles.includes(CLUB_ROLES.CLUB_MANAGER))
        .map((a) => a.golferUserId.toString()),
    );

    await this.golfClubRoleRepository.deleteByClubId(payload.clubId);

    for (const id of golferIds) {
      const roles: ClubRole[] = [];
      if (managerSet.has(id)) {
        roles.push(CLUB_ROLES.CLUB_MANAGER);
      }
      if (memberSet.has(id)) {
        roles.push(CLUB_ROLES.CLUB_MEMBER);
      }
      if (roles.length === 0) {
        continue;
      }
      await this.golfClubRoleRepository.create({
        clubId: new Types.ObjectId(payload.clubId),
        golferUserId: new Types.ObjectId(id),
        roles,
      } as Partial<IGolfClubRoleAssignment>);
    }

    const primaryManagerId = managerIds[0] ?? null;
    await this.golfClubRepository.updateById(payload.clubId, {
      managerUserId: primaryManagerId
        ? new Types.ObjectId(primaryManagerId)
        : null,
    });

    // Send credential email to newly added managers
    if (managerIds.length > 0) {
      const clubPassword = this.resolveClubPassword(
        club,
        payload.clubPassword,
      );
      const clubUser = await this.userService.getById(
        club.clubUserId.toString(),
      );
      if (clubUser) {
        for (const managerId of managerIds) {
          if (existingManagerIds.has(managerId)) continue;
          const mgr = golferMap.get(managerId);
          if (!mgr) continue;
          try {
            await this.emailService.sendGolfClubCredentials({
              to: mgr.email,
              recipientName: mgr.fullName,
              recipientRole: "Club Manager",
              clubName: club.name,
              clubEmail: clubUser.email,
              clubPassword,
            });
            logger.info(
              {
                clubId: payload.clubId,
                golferId: managerId,
                golferEmail: mgr.email,
              },
              "Club manager credentials email sent (update roles)",
            );
          } catch (error) {
            logger.error(
              {
                clubId: payload.clubId,
                golferId: managerId,
                golferEmail: mgr.email,
                error,
              },
              "Failed to send club manager credentials email (update roles)",
            );
          }
        }
      }
    }

    if (memberIdsForThread.length > 0) {
      try {
        await this.chatService.addMembersToClubGroupThreads(
          payload.clubId,
          memberIdsForThread,
        );
      } catch (error) {
        logger.error(
          { clubId: payload.clubId, memberUserIds: memberIdsForThread, error },
          "Failed to add club members to group chat threads",
        );
      }
    }

    return this.getClubRoles(payload.clubId);
  }

  async updateClubDetails(
    clubId: string,
    payload: {
      country?: string;
      city?: string;
      address?: string;
      ghinNumber?: string;
    },
  ): Promise<GolfClubResponse> {
    const club = await this.golfClubRepository.findById(clubId);
    if (!club) {
      throw new NotFoundException("Golf club not found.");
    }

    const updates: Partial<IGolfClub> = {};
    if (payload.country !== undefined) {
      updates.country = payload.country.trim();
    }
    if (payload.city !== undefined) {
      updates.city = payload.city.trim();
    }
    if (payload.address !== undefined) {
      updates.address = payload.address.trim();
    }
    if (payload.ghinNumber !== undefined) {
      updates.ghinNumber = payload.ghinNumber.trim();
    }

    const updatedClub = await this.golfClubRepository.updateById(
      clubId,
      updates,
    );
    if (!updatedClub) {
      throw new NotFoundException("Golf club not found.");
    }

    const clubUser = await this.userService.getById(
      updatedClub.clubUserId.toString(),
    );

    return this.toGolfClubResponse(updatedClub, clubUser?.email ?? "");
  }

  async updateProfileImage(
    clubId: string,
    imageUrl: string,
  ): Promise<GolfClubResponse> {
    const updatedClub = await this.golfClubRepository.updateById(clubId, {
      profileImageUrl: imageUrl,
    });
    if (!updatedClub) {
      throw new NotFoundException("Golf club not found.");
    }
    const clubUser = await this.userService.getById(
      updatedClub.clubUserId.toString(),
    );
    return this.toGolfClubResponse(updatedClub, clubUser?.email ?? "");
  }

  async updateCoverImage(
    clubId: string,
    imageUrl: string,
  ): Promise<GolfClubResponse> {
    const updatedClub = await this.golfClubRepository.updateById(clubId, {
      coverImageUrl: imageUrl,
    });
    if (!updatedClub) {
      throw new NotFoundException("Golf club not found.");
    }
    const clubUser = await this.userService.getById(
      updatedClub.clubUserId.toString(),
    );
    return this.toGolfClubResponse(updatedClub, clubUser?.email ?? "");
  }

  async assignManager(
    payload: AssignClubManagerPayload,
  ): Promise<GolfClubResponse> {
    const club = await this.golfClubRepository.findById(payload.clubId);
    if (!club) {
      throw new NotFoundException("Golf club not found.");
    }

    const golfer = await this.userService.getById(payload.golferUserId);
    if (!golfer) {
      throw new NotFoundException(MESSAGES.USER.USER_NOT_FOUND);
    }

    if (golfer.role !== ROLES.GOLFER) {
      throw new BadRequestException("Selected user is not a golfer.");
    }

    const updatedClub = await this.golfClubRepository.updateById(
      payload.clubId,
      { managerUserId: golfer._id },
    );

    if (!updatedClub) {
      throw new NotFoundException("Golf club not found.");
    }

    try {
      await this.chatService.addMembersToClubGroupThreads(payload.clubId, [
        payload.golferUserId,
      ]);
    } catch (error) {
      logger.error(
        {
          clubId: payload.clubId,
          golferUserId: payload.golferUserId,
          error,
        },
        "Failed to add club manager to group chat threads",
      );
    }

    const clubUser = await this.userService.getById(club.clubUserId.toString());
    if (!clubUser) {
      throw new NotFoundException("Golf club login not found.");
    }

    const clubPassword = this.resolveClubPassword(
      club,
      payload.clubPassword,
    );

    logger.info(
      {
        clubId: payload.clubId,
        golferId: payload.golferUserId,
      },
      "Assigning manager to club",
    );

    // Send credentials (with optional explicit password provided in request)
    try {
      await this.emailService.sendGolfClubCredentials({
        to: golfer.email,
        recipientName: golfer.fullName,
        recipientRole: "Club Manager",
        clubName: updatedClub.name,
        clubEmail: clubUser.email,
        clubPassword,
      });
      logger.info(
        {
          clubId: payload.clubId,
          golferId: payload.golferUserId,
          golferEmail: golfer.email,
        },
        "Club manager credentials email sent",
      );
    } catch (error) {
      logger.error(
        {
          clubId: payload.clubId,
          golferId: payload.golferUserId,
          golferEmail: golfer.email,
          error,
        },
        "Failed to send club manager credentials email",
      );
      throw new BadRequestException(
        "Manager assigned but email could not be sent. Please retry.",
      );
    }

    return this.toGolfClubResponse(updatedClub, clubUser.email);
  }

  async addMember(
    payload: AddClubMemberPayload,
  ): Promise<GolfClubMemberResponse> {
    const club = await this.golfClubRepository.findById(payload.clubId);
    if (!club) {
      throw new NotFoundException("Golf club not found.");
    }

    const golfer = await this.userService.getById(payload.golferUserId);
    if (!golfer) {
      throw new NotFoundException(MESSAGES.USER.USER_NOT_FOUND);
    }

    if (golfer.role !== ROLES.GOLFER) {
      throw new BadRequestException("Selected user is not a golfer.");
    }

    const existingMember =
      await this.golfClubMemberRepository.findByClubAndGolfer(
        payload.clubId,
        payload.golferUserId,
      );
    if (existingMember) {
      throw new ConflictException("Golfer is already a member of this club.");
    }

    const member = await this.golfClubMemberRepository.create({
      clubId: payload.clubId,
      golferUserId: payload.golferUserId,
    });

    try {
      await this.chatService.addMembersToClubGroupThreads(payload.clubId, [
        payload.golferUserId,
      ]);
    } catch (error) {
      logger.error(
        {
          clubId: payload.clubId,
          golferUserId: payload.golferUserId,
          error,
        },
        "Failed to add club member to group chat threads",
      );
    }

    return this.toGolfClubMemberResponse(member);
  }

  private toGolfClubResponse(
    club: IGolfClub,
    clubEmail: string,
    memberCount: number = 0,
  ): GolfClubResponse {
    return {
      _id: club._id.toString(),
      name: club.name,
      clubUserId: club.clubUserId.toString(),
      clubEmail,
      managerUserId: club.managerUserId?.toString() ?? null,
      coverImageUrl: club.coverImageUrl ?? null,
      profileImageUrl: club.profileImageUrl ?? null,
      country: club.country || "",
      city: club.city || "",
      address: club.address || "",
      ghinNumber: club.ghinNumber || "",
      memberCount,
      createdAt: club.createdAt,
      updatedAt: club.updatedAt,
    };
  }

  private toGolfClubMemberResponse(
    member: IGolfClubMember,
  ): GolfClubMemberResponse {
    return {
      _id: member._id.toString(),
      clubId: member.clubId.toString(),
      golferUserId: member.golferUserId.toString(),
      createdAt: member.createdAt,
      updatedAt: member.updatedAt,
    };
  }

  async deleteClubHard(clubId: string): Promise<void> {
    const club = await this.golfClubRepository.findById(clubId);
    if (!club) {
      throw new NotFoundException("Golf club not found.");
    }

    // Remove role assignments and members
    await this.golfClubRoleRepository.deleteByClubId(clubId);
    await this.golfClubMemberRepository.deleteByClubId(clubId);

    // Delete the club record
    await this.golfClubRepository.deleteByIdHard(clubId);

    // Delete associated club user and their refresh tokens
    await this.userService.invalidateAllRefreshTokens(
      club.clubUserId.toString(),
    );
    await this.userService.permanentlyDeleteUser(club.clubUserId.toString());
  }
}
